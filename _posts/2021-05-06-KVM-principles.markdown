---
layout: post
title:  KVM虚拟化技术-笔记
date:   2021-05-06
author: Jay Chen
tags:   [KVM]
mathjax: false
---
# description
KVM虚拟化技术简介

# 目录
- [第一章 虚拟化与云计算](#第一章-虚拟化与云计算)
- [第一章 虚拟化与云计算](#第一章-虚拟化与云计算)
  - [1.1 云计算概念](#11-云计算概念)
  - [1.2 云计算技术](#12-云计算技术)
    - [1.2.1Map/Reduce](#121mapreduce)
  - [1.3虚拟化技术](#13虚拟化技术)
    - [1.3.1软件虚拟化和硬件虚拟化](#131软件虚拟化和硬件虚拟化)
  - [1.4 KVM简介](#14-kvm简介)
  - [1.5 Xen简介](#15-xen简介)
- [第二章 KVM原理简介](#第二章-kvm原理简介)
  - [2.1 Linux操作系统简介](#21-linux操作系统简介)
  - [2.2 虚拟化模型](#22-虚拟化模型)
  - [2.3 KVM架构](#23-kvm架构)
  - [2.4 KVM模块](#24-kvm模块)
  - [2.5 QEMU设备模型](#25-qemu设备模型)
- [第三章 构建KVM环境](#第三章-构建kvm环境)
# 第一章 虚拟化与云计算

## 1.1 云计算概念

SaaS（Software as a Service，软件即服务）

PaaS（Platform as a Service，平台即服务）

IaaS（Infrastructure as a Service，基础设施即服务）



## 1.2 云计算技术

### 1.2.1Map/Reduce

是google开发的编程模型，是一种简化的分布式编程模型和高效的任务调度模型，用于大规模数据集的并行运算。应用于分布式搜索、分布式排序、机器学习、机器翻译等，包括google公司等互联网网页搜索索引。

库实现：JAVA语言下的Hadoop

## 1.3虚拟化技术

### 1.3.1软件虚拟化和硬件虚拟化

关键一步：虚拟化层必须能够截获计算元件对物理资源的直接访问，并将其重新定向到虚拟资源池中。

1、软件方案

纯软件虚拟化，用纯软件的方法在现有的物理平台上实现对物理平台访问的截获和模拟。

QEMU，通过纯软件来仿真X86平台处理器的取指、解码和执行，客户机的指令并不在物理平台上直接执行。所有指令都是软件模拟的，因此性能往往比较差，但是可以在同一平台上模拟不同架构平台的虚拟机。

2、硬件方案

硬件虚拟化，物理平台本身提供了对特殊指令的截获和重定向的硬件支持，甚至新的硬件会提供额外的资源来帮助软件实现对关键硬件资源的虚拟化，从而提升性能。

Inter VT虚拟化技术：Pentium、Core、Xeon至强，Itanium安腾

## 1.4 KVM简介

KVM全称Kernel Virtual Machine，内核虚拟机，由以色列公司Qumranet开发。KVM没有从底层开始新写一个Hypervisor，而是选择基于Linux kernel通过夹在新的模块从而使Linux kernel本身变成一个Hypervisor，2006年10月KVM模块的源代码被正式接纳进入Linux kernel。Xen不一样，会取代内核由自身管理系统资源。

在KVM架构中，虚拟机实现为常规的Linux进程，由标准Linux调度程序进行调度。KVM本身并不执行任何模拟，需要用户空间程序（QEMU）通过/dev/kvm接口设置一个客户机虚拟服务器的地址空间，向他提供模拟的I/O，并将它的视频显示映射回宿主的显示屏。

![image-20210429174649641](https://user-images.githubusercontent.com/48710834/117282972-e8905580-ae97-11eb-9548-fa393d5107c5.png)



## 1.5 Xen简介

Xen是一个直接在系统硬件上运行的虚拟机管理程序。Xen在系统给硬件与虚拟机之间插入一个虚拟化层，将系统硬件转换为一个逻辑计算资源池，Xen可以将其中的资源动态地分配给任何操作系统或应用程序。

![image-20210429174442599](https://user-images.githubusercontent.com/48710834/117283025-f80f9e80-ae97-11eb-9445-5255892368be.png)


Xen被设计成为微内核的实现，其本身只是负责管理处理器和内存资源。



# 第二章 KVM原理简介

## 2.1 Linux操作系统简介

模块化设计的Linux：

操作系统内核设计一直分为两个阵营：微内核和单内核；

单内核：整个内核从整体上作为一个单独的大过程来实现，并且同时运行在一个单独的地址空间内，所有的内核服务都在这样一个大的内核空间运行，内核之间的通信可以简单的实现为函数调用。

微内核：并不是作为一个单独的大过程来实现的，相反内核的功能被划分成为多个独立的过程，每一个过程叫做一个服务器，多个度武器程序都运行在自己的地址空间，只有少量的核心的服务器运行在特权模式，服务器之间的通信采用了进程间通信机制。

Linux采用了实用主义的设计，Linux内核被设计成单内核，同时支持模块化设计及动态装载内核模块的能力。除了诸如进程切换、内存管理等核心的内核功能，将大部分内核功能作为单独的内核模块设计并实现。内核在运行过程中，按照需求，动态的加载并连接进入内核空间运行，不使用的模块还可以在运行的过程中动态的卸载。

## 2.2 虚拟化模型

![image-20210429180256129](https://user-images.githubusercontent.com/48710834/117283106-0cec3200-ae98-11eb-9816-8d8a46b89393.png)


Hypervisor也可以称为VMM（virtual machine monitor），虚拟机监视器，在物理系统之上运行，管理真是的物理硬件平台，并为每个虚拟客户机提供对应虚拟硬件平台。

## 2.3 KVM架构

虚拟机基本架构分为两种：

类型一：在系统上电之后首先加载运行虚拟机监控程序，传统的操作系统运行在其创建的虚拟机中。从某种意义上说，可以视为操作系统内核，典型例子就是Xen、VMware的ESX/ESXi和微软的Hyper-V。

类型二：在系统上电之后仍然运行一般意义上的操作系统，虚拟机监控程序作为特殊的应用程序，可以视作操作系统功能的扩展。典型例子就是KVM、VMware Workstation、VirtualBox。

![image-20210429181440975](https://user-images.githubusercontent.com/48710834/117283058-01990680-ae98-11eb-8fe6-aaa7932f7d01.png)


KVM本身并不执行任何设备模拟，在运行时按需加载进入内核空间运行。

## 2.4 KVM模块

KVM模块是KVM虚拟机的核心部分，其主要功能是初始化CPU硬件，打开虚拟化模式，然后将虚拟客户机运行在虚拟机模式下，并对虚拟客户机的运行提供一定的支持。

KVM模块与用户空间QEMU的通信接口主要是一系列针对特殊设备文件的IOCTL调用。

创建虚拟机：针对/dev/kvm文件最重要的IOCTL调用，可以理解为KVM为了某个特定的虚拟客户机创建对应的内核数据结构，同时KVM还会返回一个文件句柄来代表所创建的虚拟机。而后可以创建用户空间虚拟地址和客户机物理地址以及真实内存物理地址的映射关系等等。

执行虚拟处理器：用户空间准备好的虚拟机在KVM模块的支持下，被置于虚拟化模式中的非根模式下，开始执行二进制指令。

内存虚拟化：客户机程序的虚拟地址转化成客户机物理地址再转化成真实物理地址。KVM使用影子页表解决这个问题，影子页表实现复杂有时候开销很大。也可以引入二级页表，称为二维分页机制。

## 2.5 QEMU设备模型

QEMU虚拟机是一个纯软件的实现，性能低下，但是其优点是在支持QEMU本身编译运行的平台上就可以实现虚拟机的功能，虚拟机可以与宿主机不是同一个架构。QEMU的代码中有整套的虚拟机实现，包括处理器虚拟化、内存虚拟化以及KVM使用到的虚拟设备模拟。

虚拟机运行期间，QEMU会通过KVM模块提供的系统调用进入内核，由KVM模块负责将虚拟机置于处理器的特殊模式运行，遇到虚拟机进行输入输出操作，KVM模块会从上次的系统调用出口处返回QEMU，由QEMU来负责解析和模拟这些设备。从QEMU的角度来看，也可以说QEMU使用了KVM模块的虚拟化功能，为自己的虚拟机提供硬件虚拟化的加速，从而极大的提高了虚拟机的性能。

# 第三章 构建KVM环境
