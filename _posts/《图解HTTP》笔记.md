# 目录
- [目录](#目录)
- [1、了解Web及网络基础](#1了解web及网络基础)
  - [1.3 网络基础TCP/IP](#13-网络基础tcpip)
  - [1.4 与HTTP关系密切的协议：IP、TCP和DNS](#14-与http关系密切的协议iptcp和dns)
    - [1.4.1 负责传输的IP协议](#141-负责传输的ip协议)
    - [1.4.2 确保可靠性的TCP协议](#142-确保可靠性的tcp协议)
  - [1.5 负责域名解析的DNS服务](#15-负责域名解析的dns服务)
  - [1.6 各种协议与HTTP协议的关系](#16-各种协议与http协议的关系)
- [2、简单的HTTP协议](#2简单的http协议)
  - [2.1 HTTP协议用于客户端和服务端之间的通信](#21-http协议用于客户端和服务端之间的通信)
  - [2.2 通过请求和响应的交换达成通信](#22-通过请求和响应的交换达成通信)
  - [2.3 HTTP是不保存状态的协议](#23-http是不保存状态的协议)
  - [2.4 请求URI定位资源](#24-请求uri定位资源)
  - [2.5 告知服务器意图的HTTP方法](#25-告知服务器意图的http方法)
  - [2.7 持久连接节省通信量](#27-持久连接节省通信量)
    - [2.7.1 持久连接](#271-持久连接)
    - [2.7.2 管线化](#272-管线化)
  - [2.8 使用Cookie的状态管理](#28-使用cookie的状态管理)
- [3、HTTP报文内的HTTP信息](#3http报文内的http信息)
  - [3.1 HTTP报文](#31-http报文)
  - [3.2 请求报文及响应报文的结构](#32-请求报文及响应报文的结构)
  - [3.3 编码提升传输速率](#33-编码提升传输速率)
    - [3.3.1 报文主体和实体主体的差异](#331-报文主体和实体主体的差异)
    - [3.3.2 压缩传输的内容编码](#332-压缩传输的内容编码)
    - [3.3.3 分割发送的分块传输编码](#333-分割发送的分块传输编码)
  - [3.4 发送多种数据的多部分对象集合](#34-发送多种数据的多部分对象集合)
  - [3.5 获取部分内容的范围请求](#35-获取部分内容的范围请求)
  - [3.6 内容协商返回最合适的内容](#36-内容协商返回最合适的内容)
- [4、返回结果的HTTP状态码](#4返回结果的http状态码)
  - [4.1 状态码告知从服务端返回的请求结果](#41-状态码告知从服务端返回的请求结果)
  - [4.2 2XX成功](#42-2xx成功)
    - [4.2.1 200 OK](#421-200-ok)
    - [4.2.2 204 NO Content](#422-204-no-content)
    - [4.2.3 206 PartialContent](#423-206-partialcontent)
  - [4.3 3XX重定向](#43-3xx重定向)
    - [4.3.1 301 Moved Permanently](#431-301-moved-permanently)
    - [4.3.2 302 Found](#432-302-found)
    - [4.3.3 303 See Other](#433-303-see-other)
    - [4.3.4 304 Not Modified](#434-304-not-modified)
    - [4.3.5 307 Temporary Redirect](#435-307-temporary-redirect)
  - [4.4 4XX客户端错误](#44-4xx客户端错误)
    - [4.4.1 400 Bad Request](#441-400-bad-request)
    - [4.4.2 401 Unauthorized](#442-401-unauthorized)
    - [4.4.3 403 Forbidden](#443-403-forbidden)
    - [4.4.4 404 Not Found](#444-404-not-found)
  - [4.5 5XX服务器错误](#45-5xx服务器错误)
    - [4.5.1 500 Internal Server Error](#451-500-internal-server-error)
    - [4.5.2 503 Service Unavailable](#452-503-service-unavailable)
- [5、与HTTP协作的Web服务器](#5与http协作的web服务器)
  - [5.1 用单台虚拟主机实现多个域名](#51-用单台虚拟主机实现多个域名)
  - [5.2 通信数据转发程序：代理、网关、隧道](#52-通信数据转发程序代理网关隧道)
    - [5.2.1 代理](#521-代理)
    - [5.2.2 网关](#522-网关)
    - [5.2.3 隧道](#523-隧道)
  - [5.3 保存资源的缓存](#53-保存资源的缓存)
    - [5.3.1 缓存的有效期限](#531-缓存的有效期限)
    - [5.3.2 客户端的缓存](#532-客户端的缓存)
- [6、HTTP首部](#6http首部)
  - [6.1 HTTP报文首部](#61-http报文首部)
  - [6.2 HTTP首部字段](#62-http首部字段)
  - [6.3 HTTP/1.1 通用首部字段](#63-http11-通用首部字段)
  - [6.4 请求首部字段](#64-请求首部字段)
  - [6.5 响应首部字段](#65-响应首部字段)
  - [6.6 实体首部字段](#66-实体首部字段)
  - [6.7 为Cookie服务的首部字段](#67-为cookie服务的首部字段)
- [7、确保Web安全的HTTPS](#7确保web安全的https)
  - [7.1 HTTP的缺点](#71-http的缺点)
    - [7.1.1 通信使用明文可能会被窃听](#711-通信使用明文可能会被窃听)
    - [7.1.2 不验证通信方的身份就可能遭遇伪装](#712-不验证通信方的身份就可能遭遇伪装)
    - [7.1.3 无法证明报文完整性，可能已遭篡改](#713-无法证明报文完整性可能已遭篡改)
  - [7.2 HTTPS = HTTP + 加密 + 认证 + 完整性保护](#72-https--http--加密--认证--完整性保护)
    - [7.2.1 **HTTP** 加上加密处理和认证以及完整性保护后即是 HTTPS](#721-http-加上加密处理和认证以及完整性保护后即是-https)
    - [7.2.2 HTTPS是身披SSL外壳的HTTP](#722-https是身披ssl外壳的http)
    - [7.2.3 相互交换密钥的公开密钥加密技术](#723-相互交换密钥的公开密钥加密技术)
    - [7.2.4 证明公开密钥正确性的证书](#724-证明公开密钥正确性的证书)
    - [7.2.5 HTTPS的安全通信机制](#725-https的安全通信机制)
- [8、确认访问用户身份的认证](#8确认访问用户身份的认证)
  - [8.1 何为认证](#81-何为认证)
  - [8.2 BASIC认证](#82-basic认证)
  - [8.3 DIGEST认证](#83-digest认证)
  - [8.4 SSL 客户端认证](#84-ssl-客户端认证)
    - [8.4.1 SSL客户端认证的步骤](#841-ssl客户端认证的步骤)
    - [8.4.2 SSL客户端认证采用双因素认证](#842-ssl客户端认证采用双因素认证)
  - [8.5 基于表单认证](#85-基于表单认证)
    - [8.5.1认证多半为基于表单认证](#851认证多半为基于表单认证)
    - [8.5.2 Session管理及Cookie应用](#852-session管理及cookie应用)
- [9、基于HTTP的功能追加协议](#9基于http的功能追加协议)
  - [9.1 基于HTTP的协议](#91-基于http的协议)
  - [9.2 消除HTTP瓶颈的SPDY](#92-消除http瓶颈的spdy)
    - [9.2.1 HTTP 的瓶颈](#921-http-的瓶颈)
- [10、构建web内容时的技术](#10构建web内容时的技术)
  - [10.1 HTM L](#101-htm-l)
    - [10.1.1 web页面几乎全由HTML构建](#1011-web页面几乎全由html构建)
    - [10.1.2 HTML的版本](#1012-html的版本)
    - [10.1.3 设计应用CSS](#1013-设计应用css)
  - [10.2 动态HTML](#102-动态html)
    - [10.2.1 让web页面动起来的动态HTML](#1021-让web页面动起来的动态html)
    - [10.2.2 更易控制HTML的DOM](#1022-更易控制html的dom)
  - [10.3 Web应用](#103-web应用)
    - [10.3.1 通过Web提供功能的Web应用](#1031-通过web提供功能的web应用)
    - [10.3.2 与Web服务器及程序协作的CGI](#1032-与web服务器及程序协作的cgi)
    - [10.3.3 因Java而普及的Servlet](#1033-因java而普及的servlet)
  - [10.4 数据发布的格式及语言](#104-数据发布的格式及语言)
    - [10.4.1 可扩展标记语言](#1041-可扩展标记语言)
    - [10.4.2 发布更新信息的RSS/Atom](#1042-发布更新信息的rssatom)
    - [10.4.3 JavaScript衍生的轻量级易用JSON](#1043-javascript衍生的轻量级易用json)
- [11、Web的攻击技术](#11web的攻击技术)
  - [11.1 针对Web的攻击技术](#111-针对web的攻击技术)
    - [11.1.1 HTTP不具备必要的安全功能](#1111-http不具备必要的安全功能)
    - [11.1.2 在客户端可篡改请求](#1112-在客户端可篡改请求)
    - [11.1.3 针对Web应用的攻击模式](#1113-针对web应用的攻击模式)
  - [11.2 因输出值转义不完全引发的安全漏洞](#112-因输出值转义不完全引发的安全漏洞)
    - [11.2.1 跨站脚本（XSS）攻击](#1121-跨站脚本xss攻击)
    - [11.2.2 SQL注入攻击](#1122-sql注入攻击)
    - [11.2.3 OS命令注入攻击](#1123-os命令注入攻击)
    - [11.2.4 HTTP首部注入攻击](#1124-http首部注入攻击)
    - [11.2.5 邮件首部注入攻击](#1125-邮件首部注入攻击)
    - [11.2.6 目录遍历攻击](#1126-目录遍历攻击)
    - [11.2.7 远程文件包含漏洞](#1127-远程文件包含漏洞)
  - [11.3 因设置或设计上的缺陷引发的安全漏洞](#113-因设置或设计上的缺陷引发的安全漏洞)
    - [11.3.1 强制浏览](#1131-强制浏览)
    - [11.3.2 不正确的错误消息处理](#1132-不正确的错误消息处理)
    - [11.3.3 开放重定向](#1133-开放重定向)
  - [11.4 因会话管理疏忽引发的安全漏洞](#114-因会话管理疏忽引发的安全漏洞)
    - [11.4.1 会话劫持](#1141-会话劫持)
    - [11.4.2 会话固定攻击](#1142-会话固定攻击)
    - [11.4.3 跨站点请求伪造](#1143-跨站点请求伪造)
  - [11.5 其他安全漏洞](#115-其他安全漏洞)
    - [11.5.1 密码破解](#1151-密码破解)
    - [11.5.2 点击劫持](#1152-点击劫持)
    - [11.5.3 DoS攻击](#1153-dos攻击)
    - [11.5.4 后门程序](#1154-后门程序)

# 1、了解Web及网络基础

## 1.3 网络基础TCP/IP

TCP/IP的分层管理：

优点在于：某个地方如果需要改变设计时，就必须把所有部分整体替换掉，但是分层之后，只需要把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。



![image-20210508114413332](/Users/user/Library/Application Support/typora-user-images/image-20210508114413332.png)

## 1.4 与HTTP关系密切的协议：IP、TCP和DNS

### 1.4.1 负责传输的IP协议

IP网际协议位于网络层，其作用时把各种数据包传送给对方。其中涉及 的两个重要条件时IP地址和MAC地址。

IP地址：指明了节点被分配到的地址；

MAC地址：网卡所属的固定地址；

IP地址--->MAC地址：ARP协议，是一种用以解析地址的协议

### 1.4.2 确保可靠性的TCP协议

TCP位于传输层，提供可靠的字节流服务，字节流服务是指将大块数据分割成以报文段为单位的数据包进行管理。

TCP协议采用三次握手：

![image-20210508115526819](/Users/user/Library/Application Support/typora-user-images/image-20210508115526819.png)

* 为何一定要用三次握手，用两次握手会出现什么问题？



## 1.5 负责域名解析的DNS服务

DNS（Domain Name System）位于应用层，提供域名到IP地址之间的解析服务。

DNS协议提供从域名查询IP地址，或者从IP地址查询域名



## 1.6 各种协议与HTTP协议的关系

![image-20210508115921367](/Users/user/Library/Application Support/typora-user-images/image-20210508115921367.png)

# 2、简单的HTTP协议

## 2.1 HTTP协议用于客户端和服务端之间的通信

客户端：请求访问文本或者图像等资源等一端；

服务端：提供资源响应的一端；

有时候按照实际情况，两台计算机作为客户算和服务端的角色有可能会呼唤，但是HTTP协议可以明确区分哪端是客户端，哪端是服务端。

## 2.2 通过请求和响应的交换达成通信

* 请求必定由客户端发出，而服务端在没有接收到请求之前不会发送响应

1、请求报文

![image-20210508120752177](/Users/user/Library/Application Support/typora-user-images/image-20210508120752177.png)

2、响应报文

![image-20210508120859602](/Users/user/Library/Application Support/typora-user-images/image-20210508120859602.png)

## 2.3 HTTP是不保存状态的协议

使用HTTP协议，每当有新的请求发送时，就会有对应新响应产生，协议本身不保留之前一切的请求或响应报文的信息。

## 2.4 请求URI定位资源

HTTP协议使用URI定位互联网上的资源

## 2.5 告知服务器意图的HTTP方法

* GET：获取资源

GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。

* POST：传输实体主体

虽然GET方法也可以传输实体的主体，但一般用POST方法传输实体

* put：传输文件

PUT方法传输文件就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定位置。但该方法本身不带验证机制，任何人都可以上传文件，存在安全性问题

* HEAD：或得报文首部

HEAD方法和GET方法一样，只是不返回报文主体部分。

* DELETE：删除文件

DELETE方法用来删除文件，是与PUT相反的方法。本身也不带验证机制，所以一般网站也不使用DELETE方法。

* OPTIONS：询问支持的方法

用来查询针对请求URI指定的资源支持的方法

* TRACE：追踪路径

让web服务器端将之前的请求通信环回给客户端的方法，用于查询发送出去的请求是怎样被加工修改的

* CONNECT：要求用隧道协议连接代理

要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL和TLS协议把通信内容加密后经网络隧道传输。

![image-20210508140400640](/Users/user/Library/Application Support/typora-user-images/image-20210508140400640.png)

## 2.7 持久连接节省通信量

HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接，但是文档中包含大量图片的情况多了起来后，每次请求都会造成无谓的TCP连接建立和断开

### 2.7.1 持久连接

特点：只要任意一端没有明确提出断开连接，则保持TCP连接状态。

在HTTP/1.1中所有的连接都是默认持久连接，但是在HTTP/1.0中并未标准化

### 2.7.2 管线化

持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应才能发送下一个请求，管线化技术出现后，不用等待响应亦可直接发送下一个请求。

## 2.8 使用Cookie的状态管理

Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的 首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器 发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。

# 3、HTTP报文内的HTTP信息

## 3.1 HTTP报文

HTTP报文大致可以分为报文首部和报文主体

## 3.2 请求报文及响应报文的结构

请求报文：

​	报文首部：

请求行；

请求首部字段；

通用首部字段；

其他；

​	空行（CR+LF）

​	报文主体：

## 3.3 编码提升传输速率

### 3.3.1 报文主体和实体主体的差异

HHTP报文的主体用于传输请求或响应的实体主体。

通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致他和报文主体产生差异。

### 3.3.2 压缩传输的内容编码

常用的内容编码有以下几种

* gzip(GNU zip)
* compress(UNIX 系统的标准压缩)
* deflate（zlib）
* identity（不进行编码）

### 3.3.3 分割发送的分块传输编码

在传输大容量数据时，通过吧数据分割成多块，能够让浏览器逐步显示页面

## 3.4 发送多种数据的多部分对象集合

发送的一份报文主体内可能包含有多类型实体，通常是在图片或文本文件等上传时使用。

## 3.5 获取部分内容的范围请求

以前，用户不能使用现在这种高速的带宽访问互联网，当时，下载一个尺寸稍大的图片或文件就已经很吃力了。如果下载过程中遇到网络中断的情况，那就必须重头开始。为了解决上述问题，需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。

要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请 求叫做范围请求(Range Request)。

对一份 10 000 字节大小的资源，如果使用范围请求，可以只请求 5001~10 000 字节内的资源。

执行范围请求时，会用到首部字段 Range 来指定资源的byte范围。

Range: bytes = 5001 - 10000

Range: bytes = 5001 -

Range: bytes = - 3000, 5001 - 10000 （多重范围）

针对范围请求，响应会返回状态码为 206 Partial Content 的响应报文。如果服务端无法响应范围请求，则会返回状态码 200 OK 和完整的实体内容。

## 3.6 内容协商返回最合适的内容

同一个 Web 网站有可能存在着多份相同内容的页面。比如英语版和中文版的 Web 页面，它们内容上虽相同，但使用的语言却不同。当浏览器的默认语言为英语或中文，访问相同 URI 的 Web 页面时， 则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容 协商(Content Negotiation)。

内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。

# 4、返回结果的HTTP状态码

## 4.1 状态码告知从服务端返回的请求结果

状态码类别：

![image-20210512182957178](/Users/user/Library/Application Support/typora-user-images/image-20210512182957178.png)

经常使用的只有14种。

## 4.2 2XX成功

### 4.2.1 200 OK

表示从客户端发来的请求在服务器端被正常处理了。

在响应报文内，随状态码一起返回的信息会因方法的不同而发生改 变。比如，使用 GET 方法时，对应请求资源的实体会作为响应返 回;而使用 HEAD 方法时，对应请求资源的实体首部不随报文主体 作为响应返回（即在响应中只返回首部，不会返回实体的主体部分）。

### 4.2.2 204 NO Content

表示服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。

另外，也不允许返回任何实体的主体。比如， 当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面 不发生更新。

### 4.2.3 206 PartialContent

表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content- Range指定范围的实体内容。

## 4.3 3XX重定向

### 4.3.1 301 Moved Permanently

永久性重定向。

该状态码表示请求的资源已被分配了新的 URI，以后 应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。

### 4.3.2 302 Found

临时性重定向。

该状态码表示请求的资源已被分配了新的 URI，希望 用户(本次)能使用新的 URI 访问。和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不 是被永久移动，只是临时性质的。换句话说，已移动的资源对应的 URI 将来还有可能发生改变。比如，用户把 URI 保存成书签，但不会 像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码 的页面对应的 URI。

### 4.3.3 303 See Other

由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。

303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确 表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。比如，当使用 POST 方法访问 CGI 程序，其执行后的处理结果是希望 客户端能以 GET 方法重定向到另一个 URI 上去时，返回 303 状态 码。虽然 302 Found 状态码也可以实现相同的功能，但这里使用 303状态码是最理想的。

### 4.3.4 304 Not Modified

表示客户端发送附带条件的请求时，服务端允许请求访问资源，但未满足条件的情况。

304 状态码返回时，不包含任何响应 的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。

### 4.3.5 307 Temporary Redirect

临时重定向。

该状态码与302 Found 有相同的含义。尽管302 标准禁止POST变换成GET，但实际使用时大家并不遵守。

## 4.4 4XX客户端错误

### 4.4.1 400 Bad Request

表示请求报文中存在语法错误。

当错误发生时，需修改请求 的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。

### 4.4.2 401 Unauthorized

表示发送的请求需要有通过 HTTP 认证(BASIC 认证、 DIGEST 认证)的认证信息。

另外若之前已进行过 1 次请求，则表示 用 户认证失败。

返回含有 401 的响应必须包含一个适用于被请求资源的 WWW- Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收 到 401 响应，会弹出认证用的对话窗口。

### 4.4.3 403 Forbidden

表明对请求资源的访问被服务器拒绝了。

服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。

未获得文件系统的访问授权，访问权限出现某些问题(从未授权的发送源 IP 地址试图访问)等列举的情况都可能是发生 403 的原因。

### 4.4.4 404 Not Found

表明服务器上无法找到请求的资源。

除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。

## 4.5 5XX服务器错误

### 4.5.1 500 Internal Server Error

表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。

### 4.5.2 503 Service Unavailable

表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

# 5、与HTTP协作的Web服务器

## 5.1 用单台虚拟主机实现多个域名

HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。比如，提 供 Web 托管服务(Web Hosting Service)的供应商，可以用一台服务 器为多位客户服务，也可以以每位客户持有的域名运行各自不同的网 站。这是因为利用了虚拟主机(Virtual Host，又称虚拟服务器)的功 能。

如果一台服务器内托管了 www.tricorder.jp 和 www.hackr.jp 这 两个域名，他们使用相同的IP地址，使用DNS服务解析域名之后，两者的访问IP地址相同。

在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名 的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指 定主机名或域名的 URI。

## 5.2 通信数据转发程序：代理、网关、隧道

HTTP通信时，除了客户端和服务端之外，还有一些用于通信数据转发的应用程序，例如代理、网关、隧道。

### 5.2.1 代理

代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。

代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务 器。代理不改变请求 URI，会直接发送给前方持有资源的目标服务 器。

![image-20210512202119273](/Users/user/Library/Application Support/typora-user-images/image-20210512202119273.png)

每次通过代理服务器转发请求或响应时，会追加写入 **Via** 首 部信息。

* 使用代理服务器的理由有:

  1、利用缓存技术(稍后讲解)减少网络带宽的流量；

  2、组织内部针对特定网站的访问控制；

  3、以获取访问日志为主要目的，等等。

* 代理的两种使用方法：

  1、是否使用缓存；

  缓存代理：代理转发响应时，缓存代理(Caching Proxy)会预先将资源的副本 (缓存)保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。

  2、是否会修改报文；

  透明代理：转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理 (Transparent Proxy)。反之，对报文内容进行加工的代理被称为非 透明代理。

### 5.2.2 网关

网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。

* 作用：

  1、利用网关可以由HTTP请求转化为其他协议通信；

  2、利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信 线路上加密以确保连接的安全。比如，网关可以连接数据库，使用 SQL 语句查询数据。另外，在 Web 购物网站上进行信用卡结算时， 网关可以和信用卡结算系统联动。

### 5.2.3 隧道

隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。

隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等 加密手段进行通信。

* 作用：确保客户端能与服务器进行安全的通信。

隧道本身不会去解析 HTTP 请求。也就是说，请求保持原样中转给之 后的服务器。隧道会在通信双方断开连接时结束。

## 5.3 保存资源的缓存

缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。

### 5.3.1 缓存的有效期限

即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源 服务器确认资源的有效性。若判断缓存失效，缓存服务器将会再次从 源服务器上获取“新”资源。

### 5.3.2 客户端的缓存

浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取。

另外，和缓存服务器相同的一点是，当判定缓存过期后，会向源服务器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求新资源。

# 6、HTTP首部

## 6.1 HTTP报文首部

HTTP 协议的请求和响应报文中必定包含 HTTP 首部。首部内容为客户端和服务器分别处理请求和响应提供所需要的信息。

## 6.2 HTTP首部字段



## 6.3 HTTP/1.1 通用首部字段

## 6.4 请求首部字段

## 6.5 响应首部字段

## 6.6 实体首部字段



## 6.7 为Cookie服务的首部字段



# 7、确保Web安全的HTTPS

## 7.1 HTTP的缺点

* 不足之处：

  1、通信使用明文（不加密），内容可能会被窃听；

  2、不验证通信方的身份，因此有可能遭遇伪装；

  3、无法证明报文的完整性，所以有可能已遭篡改；

### 7.1.1 通信使用明文可能会被窃听

HTTP报文使用明文方式发送。

* TCP/IP是可能被窃听的网络

窃听相同段上的通信并非难事。只需要收集在互联网上流动的数 据包(帧)就行了。对于收集来的数据包的解析工作，可交给那 些抓包(Packet Capture)或嗅探器(Sniffer)工具。

* 加密处理防止被窃听

加密对象：

**1、通信的加密**

HTTP协议中没有加密机制，但是可以通过和 SSL(Secure Socket Layer，安全套接层)或 TLS(Transport Layer Security，安全层传输协议)的组合使用， 加密 HTTP 的通信内容。用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS(HTTP Secure，超文本传输安全协议)或 HTTP over SSL。

**2、内容的加密**

在这种情况下，客户端需要对 HTTP 报文进行加密处理后再发送 请求。

为了做到有效的内容加密，前提是要求客户端和服务器同 时具备加密和解密机制。主要应用在 Web 服务中。

### 7.1.2 不验证通信方的身份就可能遭遇伪装

HTTP 协议中的请求和响应不会对通信方进行确认。也就是说存在“服 务器是否就是发送请求中 URI 真正指定的主机，返回的响应是否真的 返回到实际提出请求的客户端”等类似问题。

* 任何人都可以发起请求

  在 HTTP 协议通信时，由于不存在确认通信方的处理步骤，任何 人都可以发起请求。另外，服务器只要接收到请求，不管对方是 谁都会返回一个响应(但也仅限于发送端的 IP 地址和端口号没 有被 Web 服务器设定限制访问的前提下)。

* 不确认通信方，会存在以下隐患

  1、无法确定请求发送至目标的 **Web** 服务器是否是按真实意 图返回响应的那台服务器。有可能是已伪装的 **Web** 服务 器。

  2、无法确定响应返回到的客户端是否是按真实意图接收响 应的那个客户端。有可能是已伪装的客户端。

  3、无法确定正在通信的对方是否具备访问权限。因为某些 **Web** 服务器上保存着重要的信息，只想发给特定用户通 信的权限。

  4、无法判定请求是来自何方、出自谁手。

  5、即使是无意义的请求也会照单全收。无法阻止海量请求下的 **DoS** 攻击(**Denial of Service**，拒绝服务攻击)。

* 查明对手的证书

  虽然使用 HTTP 协议无法确定通信方，但如果使用 SSL 则可以。 SSL 不仅提供加密处理，而且还使用了一种被称为证书的手段， 可用于确定方。

  证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外，伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方(服务器或客户端)持有的证书，即可判断通信方的真实意图。

### 7.1.3 无法证明报文完整性，可能已遭篡改

* 接收到的内容可能有误

  由于 HTTP 协议无法证明通信的报文完整性，因此，在请求或响 应送出之后直到对方接收之前的这段时间内，即使请求或响应的 内容遭到篡改，也没有办法获悉。换句话说，没有任何办法确认，发出的请求 / 响应和接收到的请 求 / 响应是前后相同的。

* 如何防止篡改

  虽然有使用 HTTP 协议确定报文完整性的方法，但事实上并不便 捷、可靠。其中常用的是 MD5 和 SHA-1 等散列值校验的方法， 以及用来确认文件的数字签名方法。

  可惜的是，用这些方法也依然无法百分百保证确认结果正确。因 为 PGP 和 MD5 本身被改写的话，用户是没有办法意识到的。为了有效防止这些弊端，有必要使用 HTTPS。SSL 提供认证和加 密处理及摘要功能。仅靠 HTTP 确保完整性是非常困难的，因此 通过和其他协议组合使用来实现这个目标。

## 7.2 HTTPS = HTTP + 加密 + 认证 + 完整性保护

### 7.2.1 **HTTP** 加上加密处理和认证以及完整性保护后即是 HTTPS

### 7.2.2 HTTPS是身披SSL外壳的HTTP

HTTPS并非是应用层的一种新协议，只是HTTP通信接口部分用SSL和TLS协议代替而已。

通常，HTTP直接和TCP通信，当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信。在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。

其他运行在应用层的SMTP和Telnet等协议均可配合SSL使用。

### 7.2.3 相互交换密钥的公开密钥加密技术

SSL采用一种公开密钥加密的处理方式。

* 共享密钥加密的困境

加密和解密同用一个密钥的方式称为共享密钥加密，也叫做对称密钥加密。但是以共享密钥方式加密时必须将密钥也发送给对方，如何才能安全转交？

* 使用两把密钥的公开密钥加密

公开密钥加密方式很好解决了共享密钥加密的困难。公开密钥加密使用一对非对称的密钥，一把叫做私有密钥，一把叫做公开密钥。

使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。

* HTTPS采用混合加密机制

HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密 机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开 密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处 理速度要慢。所以应充分利用两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。

### 7.2.4 证明公开密钥正确性的证书

公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。比如，正准备和某台服务器建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。

为了解决上述问题，可以使用由数字证书认证机构(CA，Certificate Authority)和其相关机关颁发的公开密钥证书。

### 7.2.5 HTTPS的安全通信机制

SSL 的慢分两种。一种是指通信慢。另一种是指由于大量消耗CPU 及内存等资源，导致处理速度变慢。和使用 HTTP 相比，网络负载可能会变慢 2 到 100 倍。除去和 TCP 连接、发送 HTTP 请求 • 响应以外，还必须进行 SSL 通信， 因此整体上处理通信量不可避免会增加。

# 8、确认访问用户身份的认证

某些 Web 页面只想让特定的人浏览，或者干脆仅本人可见。为达到 这个目标，必不可少的就是认证功能。

## 8.1 何为认证

核对本人才知道的信息：

密码、动态令牌、数字证书、生物认证、IC卡

HTTP使用的认证方式：

BASIC认证（基本认证）、DIGEST认证（摘要认证）、SSL客户端认证、FormBase认证（基于表单认证）

## 8.2 BASIC认证

是web服务器与通信客户端之间的认证方式。

步骤 **1**: 当请求的资源需要 BASIC 认证时，服务器会随状态码 401 Authorization Required，返回带 WWW-Authenticate 首部字段的响应。 该字段内包含认证的方式(BASIC) 及 Request-URI 安全域字符串 (realm)。

步骤 **2**: 接收到状态码 401 的客户端为了通过 BASIC 认证，需要将 用户 ID 及密码发送给服务器。发送的字符串内容是由用户 ID 和密码 构成，两者中间以冒号(:)连接后，再经过 Base64 编码处理。

假设用户 ID 为 guest，密码是 guest，连接起来就会形成 guest:guest 这 样的字符串。然后经过 Base64 编码，最后的结果即是 Z3Vlc3Q6Z3Vlc3Q=。把这串字符串写入首部字段 Authorization 后， 发送请求。

当用户代理为浏览器时，用户仅需输入用户 ID 和密码即可，之后， 浏览器会自动完成到 Base64 编码的转换工作。

步骤 **3**: 接收到包含首部字段 Authorization 请求的服务器，会对认证 信息的正确性进行验证。如验证通过，则返回一条包含 Request-URI 资源的响应。



BASIC 认证虽然采用 Base64 编码方式，但这不是加密处理。不需要 任何附加信息即可对其解码。换言之，由于明文解码后就是用户 ID 和密码，在 HTTP 等非加密通信的线路上进行 BASIC 认证的过程 中，如果被人窃听，被盗的可能性极高。

## 8.3 DIGEST认证

为弥补 BASIC 认证存在的弱点，从 HTTP/1.1 起就有了 DIGEST 认 证。 DIGEST 认证同样使用质询 / 响应的方式 (challenge/response)，但不会像 BASIC 认证那样直接发送明文密码。

步骤 **1**: 请求需认证的资源时，服务器会随着状态码 401 Authorization Required，返 回带 WWW-Authenticate 首部字段的响应。 该字段内包含质问响应方式认证所需的临时质询码(随机数， nonce)。

首部字段 WWW-Authenticate 内必须包含 realm 和 nonce 这两个字段的 信息。客户端就是依靠向服务器回送这两个值进行认证的。

nonce 是一种每次随返回的 401 响应生成的任意随机字符串。该字符 串通常推荐由 Base64 编码的十六进制数的组成形式，但实际内容依 赖服务器的具体实现。

步骤 **2**: 接收到 401 状态码的客户端，返回的响应中包含 DIGEST 认 证必须的首部字段 Authorization 信息。

首部字段 Authorization 内必须包含 username、realm、nonce、uri 和 response 的字段信息。其中，realm 和 nonce 就是之前从服务器接收到 的响应中的字段。

username 是 realm 限定范围内可进行认证的用户名。

uri(digest-uri)即 Request-URI 的值，但考虑到经代理转发后 Request-URI 的值可能被修改，因此事先会复制一份副本保存在 uri 内。

response 也可叫做 Request-Digest，存放经过 MD5 运算后的密码字符 串，形成响应码。

响应中其他的实体请参见第 6 章的请求首部字段 Authorization。另 外，有关 Request-Digest 的计算规则较复杂，有兴趣的读者不妨深入 学习一下 RFC2617。

步骤 **3**: 接收到包含首部字段 Authorization 请求的服务器，会确认认 证信息的正确性。认证通过后则返回包含 Request-URI 资源的响应。



DIGEST 认证提供了高于 BASIC 认证的安全等级，但是和 HTTPS 的 客户端认证相比仍旧很弱。DIGEST 认证提供防止密码被窃听的保护 机制，但并不存在防止用户伪装的保护机制。

DIGEST 认证和 BASIC 认证一样，使用上不那么便捷灵活，且仍达不 到多数 Web 网站对高度安全等级的追求标准。

## 8.4 SSL 客户端认证

SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借 客户端证书(在 HTTPS 一章已讲解)认证，服务器可确认访问是否 来自已登录的客户端。

### 8.4.1 SSL客户端认证的步骤

为达到 SSL 客户端认证的目的，需要事先将客户端证书分发给客户端，且客户端必须安装此证书。

 步骤 **1**: 接收到需要认证资源的请求，服务器会发送 CertificateRequest 报文，要求客户端提供客户端证书。

 步骤 **2**: 用户选择将发送的客户端证书后，客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。

步骤 **3**: 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信。

### 8.4.2 SSL客户端认证采用双因素认证

在多数情况下，SSL 客户端认证不会仅依靠证书完成认证，一般会和 基于表单认证(稍后讲解)组合形成一种双因素认证(Two-factor authentication)来使用。所谓双因素认证就是指，认证过程中不仅需 要密码这一个因素，还需要申请认证者提供其他持有信息，从而作为 另一个因素，与其组合使用的认证方式。

换言之，第一个认证因素的 SSL 客户端证书用来认证客户端计算机， 另一个认证因素的密码则用来确定这是用户本人的行为。

通过双因素认证后，就可以确认是用户本人正在使用匹配正确的计算机访问服务器。

## 8.5 基于表单认证

基于表单的认证方法并不是在 HTTP 协议中定义的。客户端会向服务 器上的 Web 应用程序发送登录信息(Credential)，按登录信息的验 证结果认证。

### 8.5.1认证多半为基于表单认证

由于使用上的便利性及安全性问题，HTTP 协议标准提供的 BASIC 认 证和 DIGEST 认证几乎不怎么使用。另外，SSL 客户端认证虽然具有 高度的安全等级，但因为导入及维持费用等问题，还尚未普及。

### 8.5.2 Session管理及Cookie应用

基于表单认证的标准规范尚未有定论，一般会使用 Cookie 来管理Session(会话)。

鉴于 HTTP 是无状态协议，之前已认证成功的用户状态无法通过协 议层面保存下来。即，无法实现状态管理，因此即使当该用户下一次 继续访问，也无法区分他与其他的用户。于是我们会使用 Cookie 来 管理 Session，以弥补 HTTP 协议中不存在的状态管理功能。



步骤 **1**: 客户端把用户 ID 和密码等登录信息放入报文的实体部分， 通常是以 POST 方法把请求发送给服务器。而这时，会使用 HTTPS 通信来进行 HTML 表单画面的显示和用户输入数据的发送。

步骤 **2**: 服务器会发放用以识别用户的 Session ID。通过验证从客户 端发送过来的登录信息进行身份认证，然后把用户的认证状态与 Session ID 绑定后记录在服务器端。

向客户端返回响应时，会在首部字段 Set-Cookie 内写入 Session ID(如 PHPSESSID=028a8c...)。

你可以把 Session ID 想象成一种用以区分不同用户的等位号。

然而，如果 Session ID 被第三方盗走，对方就可以伪装成你的身份进 行恶意操作了。因此必须防止 Session ID 被盗，或被猜出。为了做到 这点，Session ID 应使用难以推测的字符串，且服务器端也需要进行 有效期的管理，保证其安全性。

另外，为减轻跨站脚本攻击(XSS)造成的损失，建议事先在 Cookie 内加上 httponly 属性。

步骤 **3**: 客户端接收到从服务器端发来的 Session ID 后，会将其作为 Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送 Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证 接收到的 Session ID 识别用户和其认证状态。

# 9、基于HTTP的功能追加协议

## 9.1 基于HTTP的协议

在建立 HTTP 标准规范时，制订者主要想把 HTTP 当作传输 HTML 文 档的协议。随着时代的发展，Web 的用途更具多样性，比如演化成在 线购物网站、SNS(Social Networking Service，社交网络服务)、企 业或组织内部的各种管理工具，等等。

而这些网站所追求的功能可通过 Web 应用和脚本程序实现。即使这 些功能已经满足需求，在性能上却未必最优，这是因为 HTTP 协议上 的限制以及自身性能有限。

## 9.2 消除HTTP瓶颈的SPDY

Google 在 2010 年发布了 SPDY(取自 SPeeDY，发音同 speedy)，其 开发目标旨在解决 HTTP 的性能瓶颈，缩短 Web 页面的加载时间 (50%)。

**SPDY- The ChromiumProjects**

http://www.chromium.org/spdy/

### 9.2.1 HTTP 的瓶颈

* 一条连接上只可发送一个请求；
* 请求只能从客户端开始。客户端不可以接收除响应以外的指 令；
* 请求 **/** 响应首部未经压缩就发送。首部信息越多延迟越大；
* 发送冗长的首部。每次互相发送相同的首部造成的浪费较 多；
* 可任意选择数据压缩格式。非强制压缩发送；



# 10、构建web内容时的技术

## 10.1 HTM L

### 10.1.1 web页面几乎全由HTML构建

HTML(HyperText Markup Language，超文本标记语言)是为了发送 Web 上的超文本(Hypertext)而开发的标记语言。超文本是一种文档 系统，可将文档中任意位置的信息与其他信息(文本或图片等)建立 关联，即超链接文本。标记语言是指通过在文档的某部分穿插特别的 字符串标签，用来修饰文档的语言。我们把出现在 HTML 文档内的 这种特殊字符串叫做 HTML 标签(Tag)。

### 10.1.2 HTML的版本

时至今日，HTML 仍存在较多悬而未决问题。有些浏览器未遵循 HTML 标准实现，或扩展自用标签等，这都反映了 HTML 的标准实际 上尚未统一这一现状。

### 10.1.3 设计应用CSS

CSS(Cascading Style Sheets，层叠样式表)可以指定如何展现 HTML 内的各种元素，属于样式表标准之一。即使是相同的 HTML 文档， 通过改变应用的 CSS，用浏览器看到的页面外观也会随之改变。CSS 的理念就是让文档的结构和设计分离，达到解耦的目的。

## 10.2 动态HTML

### 10.2.1 让web页面动起来的动态HTML

所谓动态 HTML(Dynamic HTML)，是指使用客户端脚本语言将静 态的 HTML 内容变成动态的技术的总称。鼠标单击点开的新闻、 Google Maps 等可滚动的地图就用到了动态 HTML。

动态 HTML 技术是通过调用客户端脚本语言 JavaScript，实现对 HTML 的 Web 页面的动态改造。利用 DOM(Document Object Model，文档对象模型)可指定欲发生动态变化的 HTML 元素。

### 10.2.2 更易控制HTML的DOM

DOM 是用以操作 HTML 文档和 XML 文档的 API(Application Programming Interface，应用编程接口)。使用 DOM 可以将 HTML 内 的元素当作对象操作，如取出元素内的字符串、改变那个 CSS 的属 性等，使页面的设计发生改变。

## 10.3 Web应用

### 10.3.1 通过Web提供功能的Web应用

Web 应用是指通过 Web 功能提供的应用程序。比如购物网站、网上 银行、SNS、BBS、搜索引擎和 e-learning 等。互联网(Internet)或企 业内网(Intranet)上遍布各式各样的 Web 应用。

原本应用 HTTP 协议的 Web 的机制就是对客户端发来的请求，返回 事前准备好的内容。可随着 Web 越来越普及，仅靠这样的做法已不 足以应对所有的需求，更需要引入由程序创建 HTML 内容的做法。

类似这种由程序创建的内容称为动态内容，而事先准备好的内容称为 静态内容。Web 应用则作用于动态内容之上。

### 10.3.2 与Web服务器及程序协作的CGI

CGI(Common Gateway Interface，通用网关接口)是指 Web 服务器在 接收到客户端发送过来的请求后转发给程序的一组机制。在 CGI 的 作用下，程序会对请求内容做出相应的动作，比如创建 HTML 等动态内容。

使用 CGI 的程序叫做 CGI 程序，通常是用 Perl、PHP、Ruby 和 C 等 编程语言编写而成。

### 10.3.3 因Java而普及的Servlet

Servlet1 是一种能在服务器上创建动态内容的程序。Servlet 是用 Java 语言实现的一个接口，属于面向企业级 Java(JavaEE，Java Enterprise Edition)的一部分。

## 10.4 数据发布的格式及语言

### 10.4.1 可扩展标记语言

XML(eXtensible Markup Language，可扩展标记语言)是一种可按应 用目标进行扩展的通用标记语言。旨在通过使用 XML，使互联网数 据共享变得更容易。

XML 和 HTML 一样，使用标签构成树形结构，并且可自定义扩展标 签。

从 XML 文档中读取数据比起 HTML 更为简单。由于 XML 的结构基 本上都是用标签分割而成的树形结构，因此通过语法分析器 (Parser)的解析功能解析 XML 结构并取出数据元素，可更容易地对 数据进行读取。

更容易地复用数据使得 XML 在互联网上被广泛接受。比如，可用在 2 个不同的应用之间的交换数据格式化。

### 10.4.2 发布更新信息的RSS/Atom

RSS(简易信息聚合，也叫聚合内容)和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称。两者都用到了 XML。

### 10.4.3 JavaScript衍生的轻量级易用JSON

JSON(JavaScript Object Notation)是一种以 JavaScript(ECMAScript)的对象表示法为基础的轻量级数据标记语 言。能够处理的数据类型有 false/null/true/ 对象 / 数组 / 数字 / 字符 串，这 7 种类型。

# 11、Web的攻击技术

## 11.1 针对Web的攻击技术

简单的 HTTP 协议本身并不存在安全性问题，因此协议本身几乎不会 成为攻击的对象。应用 HTTP 协议的服务器和客户端，以及运行在服 务器上的 Web 应用等资源才是攻击目标。

目前，来自互联网的攻击大多是冲着 Web 站点来的，它们大多把 Web 应用作为攻击目标。本章主要针对 Web 应用的攻击技术进行讲 解。

### 11.1.1 HTTP不具备必要的安全功能

就拿远程登录时会用到的 SSH 协议来说，SSH 具备协议级别的认证 及会话管理等功能，HTTP 协议则没有。另外在架设 SSH 服务方面， 任何人都可以轻易地创建安全等级高的服务，而 HTTP 即使已架设好 服务器，但若想提供服务器基础上的 Web 应用，很多情况下都需要 重新开发。

因此，开发者需要自行设计并开发认证及会话管理功能来满足 Web 应用的安全。而自行设计就意味着会出现各种形形色色的实现。结 果，安全等级并不完备，可仍在运作的 Web 应用背后却隐藏着各种 容易被攻击者滥用的安全漏洞的 Bug。

### 11.1.2 在客户端可篡改请求

在 Web 应用中，从浏览器那接收到的 HTTP 请求的全部内容，都可 以在客户端自由地变更、篡改。所以 Web 应用可能会接收到与预期 数据不相同的内容。

在 HTTP 请求报文内加载攻击代码，就能发起对 Web 应用的攻击。 通过 URL 查询字段或表单、HTTP 首部、Cookie 等途径把攻击代码传 入，若这时 Web 应用存在安全漏洞，那内部信息就会遭到窃取，或 被攻击者拿到管理权限。

### 11.1.3 针对Web应用的攻击模式

对Web应用的攻击模式有一下两种：主动攻击、被动攻击

* 以服务器为目标的主动攻击

主动攻击(active attack)是指攻击者通过直接访问 Web 应用， 把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的 资源进行攻击，因此攻击者需要能够访问到那些资源。

主动攻击模式里具有代表性的攻击是 SQL 注入攻击和 OS 命令注 入攻击。

* 以服务器为目标的被动攻击

被动攻击(passive attack)是指利用圈套策略执行攻击代码的攻 击模式。在被动攻击过程中，攻击者不直接对目标 Web 应用访 问发起攻击。

步骤 **1**: 攻击者诱使用户触发已设置好的陷阱，而陷阱会启动发

送已嵌入攻击代码的 HTTP 请求。
 步骤 **2**: 当用户不知不觉中招之后，用户的浏览器或邮件客户端

就会触发这个陷阱。
 步骤 **3**: 中招后的用户浏览器会把含有攻击代码的 HTTP 请求发

送给作为攻击目标的 Web 应用，运行攻击代码。

步骤 **4**: 执行完攻击代码，存在安全漏洞的 Web 应用会成为攻 击者的跳板，可能导致用户所持的 Cookie 等个人信息被窃取， 登录状态中的用户权限遭恶意滥用等后果。

被动攻击模式中具有代表性的攻击是跨站脚本攻击和跨站点请求伪造。

## 11.2 因输出值转义不完全引发的安全漏洞

实施Web应用的安全对策可大致分为以下两部分：

* 客户端的验证
* 服务端（Web应用端）的验证：输入值验证、输出值转义

多数情况下采用 JavaScript 在客户端验证数据。可是在客户端允许篡 改数据或关闭 JavaScript，不适合将 JavaScript 验证作为安全的防范 对策。保留客户端验证只是为了尽早地辨识输入错误，起到提高 UI 体验的作用。

Web 应用端的输入值验证按 Web 应用内的处理则有可能被误认为是 具有攻击性意义的代码。输入值验证通常是指检查是否是符合系统业 务逻辑的数值或检查字符编码等预防对策。

从数据库或文件系统、HTML、邮件等输出 Web 应用处理的数据之 际，针对输出做值转义处理是一项至关重要的安全策略。当输出值转 义不完全时，会因触发攻击者传入的攻击代码，而给输出对象带来损 害。

### 11.2.1 跨站脚本（XSS）攻击

跨站脚本攻击(Cross-Site Scripting，XSS)是指通过存在安全漏洞的 Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript 进 行的一种攻击。动态创建的 HTML 部分有可能隐藏着安全漏洞。就 这样，攻击者编写脚本设下陷阱，用户在自己的浏览器上运行时，一 不小心就会受到被动攻击。

跨站脚本攻击有可能造成以下影响。 

* 利用虚假输入表单骗取用户个人信息。

* 利用脚本窃取用户的 **Cookie** 值，被害者在不知情的情况下， 帮助攻击者发送恶意请求。

* 显示伪造的文章或图片

### 11.2.2 SQL注入攻击

* 会执行非法SQL的SQL注入攻击

SQL 注入(SQL Injection)是指针对 Web 应用使用的数据库，通 过运行非法的 SQL 而产生的攻击。该安全隐患有可能引发极大 的威胁，有时会直接导致个人信息及机密信息的泄露。

Web 应用通常都会用到数据库，当需要对数据库表内的数据进行 检索或添加、删除等操作时，会使用 SQL 语句连接数据库进行 特定的操作。如果在调用 SQL 语句的方式上存在疏漏，就有可 能执行被恶意注入(Injection)非法 SQL 语句。

SQL 注入攻击有可能会造成以下等影响：非法查看或篡改数据库内的数据、规避认证、执行和数据库服务器业务关联的程序等

### 11.2.3 OS命令注入攻击

OS 命令注入攻击(OS Command Injection)是指通过 Web 应用，执行 非法的操作系统命令达到攻击的目的。只要在能调用 Shell 函数的地 方就有存在被攻击的风险。

可以从 Web 应用中通过 Shell 来调用操作系统命令。倘若调用 Shell 时存在疏漏，就可以执行插入的非法 OS 命令。

OS 命令注入攻击可以向 Shell 发送命令，让 Windows 或 Linux 操作系 统的命令行启动程序。也就是说，通过 OS 注入攻击可执行 OS 上安 装着的各种程序。

### 11.2.4 HTTP首部注入攻击

HTTP 首部注入攻击(HTTP Header Injection)是指攻击者通过在响应首部字段内插入该行，添加任意响应首部或主体的一种攻击。属于被动攻击模式。

HTTP 首部注入攻击有可能会造成以下一些影响：

* 设置任何 **Cookie** 信息
* 重定向至任意 **URL** 
* 显示任意的主体(**HTTP** 响应截断攻击)

### 11.2.5 邮件首部注入攻击

邮件首部注入(Mail Header Injection)是指 Web 应用中的邮件发送功 能，攻击者通过向邮件首部 To 或 Subject 内任意添加非法内容发起的 攻击。利用存在安全漏洞的 Web 网站，可对任意邮件地址发送广告 邮件或病毒邮件。

### 11.2.6 目录遍历攻击

目录遍历(Directory Traversal)攻击是指对本无意公开的文件目录， 通过非法截断其目录路径后，达成访问目的的一种攻击。这种攻击有 时也称为路径遍历(Path Traversal)攻击。

通过 Web 应用对文件处理操作时，在由外部指定文件名的处理存在 疏漏的情况下，用户可使用 .../ 等相对路径定位到 /etc/passed 等绝对 路径上，因此服务器上任意的文件或文件目录皆有可能被访问到。这 样一来，就有可能非法浏览、篡改或删除 Web 服务器上的文件。

### 11.2.7 远程文件包含漏洞

远程文件包含漏洞(Remote File Inclusion)是指当部分脚本内容需要 从其他文件读入时，攻击者利用指定外部服务器的 URL 充当依赖文 件，让脚本读取之后，就可运行任意脚本的一种攻击。

这主要是 PHP 存在的安全漏洞，对 PHP 的 include 或 require 来说， 这是一种可通过设定，指定外部服务器的 URL 作为文件名的功能。 但是，该功能太危险，PHP5.2.0 之后默认设定此功能无效。

## 11.3 因设置或设计上的缺陷引发的安全漏洞

### 11.3.1 强制浏览

强制浏览(Forced Browsing)安全漏洞是指，从安置在 Web 服务器的公开目录下的文件中，浏览那些原本非自愿公开的文件。

对那些原本不愿公开的文件，为了保证安全会隐蔽其 URL。可一旦知 道了那些 URL，也就意味着可浏览 URL 对应的文件。直接显示容易 推测的文件名或文件目录索引时，通过某些方法可能会使 URL 产生泄露。

### 11.3.2 不正确的错误消息处理

不正确的错误消息处理(Error Handling Vulnerability)的安全漏洞是 指，Web 应用的错误信息内包含对攻击者有用的信息。与 Web 应用 有关的主要错误信息如下所示。

* **Web** 应用抛出的错误消息

* 数据库等系统抛出的错误消息

### 11.3.3 开放重定向

开放重定向(Open Redirect)是一种对指定的任意 URL 作重定向跳转 的功能。而于此功能相关联的安全漏洞是指，假如指定的重定向 URL 到某个具有恶意的 Web 网站，那么用户就会被诱导至那个 Web 网 站。

## 11.4 因会话管理疏忽引发的安全漏洞

会话管理是用来管理用户状态的必备功能，但是如果在会话管理上有所疏忽，就会导致用户的认证状态被窃取等后果。

### 11.4.1 会话劫持

会话劫持(Session Hijack)是指攻击者通过某种手段拿到了用户的会 话 ID，并非法使用此会话 ID 伪装成用户，达到攻击的目的。

具备认证功能的 Web 应用，使用会话 ID 的会话管理机制，作为管理 认证状态的主流方式。会话 ID 中记录客户端的 Cookie 等信息，服务 器端将会话 ID 与认证状态进行一对一匹配管理。

下面列举了几种攻击者可获得会话 ID 的途径：

* 通过非正规的生成方法推测会话ID
* 通过窃听或 **XSS** 攻击盗取会话 **ID**
* 通过会话固定攻击(**Session Fixation**)强行获取会话 **ID**

### 11.4.2 会话固定攻击

对以窃取目标会话 ID 为主动攻击手段的会话劫持而言，会话固定攻 击(Session Fixation)攻击会强制用户使用攻击者指定的会话 ID，属 于被动攻击。

攻击者准备陷阱，先访问 Web 网站拿到会话 ID(SID=f5d1278e8109)。此刻，会话 ID 在服务器上的记录仍 是(未认证)状态。(步骤1 ~ 2)

攻击者设置好强制用户使用该会话 ID 的陷阱，并等待用户拿着 这个会话 ID 前去认证。一旦用户触发陷阱并完成认证，会话 ID(SID=f5d1278e8109)在服务器上的状态(用户 A 已认证)就 会被记录下来。(步骤3)

攻击者估计用户差不多已触发陷阱后，再利用之前这个会话 ID 访问网站。由于该会话 ID 目前已是(用户 A 已认证)状态，于 是攻击者作为用户 A 的身份顺利登录网站。

### 11.4.3 跨站点请求伪造

跨站点请求伪造(Cross-Site Request Forgeries，CSRF)攻击是指攻击 者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信 息或设定信息等某些状态更新，属于被动攻击。

## 11.5 其他安全漏洞

### 11.5.1 密码破解

密码破解的两种手段：

通过网络的密码试错、对已加密密码的破解(指攻击者入侵系统，已获得加密或散 列处理的密码数据的情况)

* 通过网络进行密码试错

1、穷举法

穷举法(Brute-force Attack，又称暴力破解法)是指对所有密钥 集合构成的密钥空间(Keyspace)进行穷举。即，用所有可行的 候选密码对目标的密码系统试错，用以突破验证的一种攻击。

2、字典攻击

字典攻击是指利用事先收集好的候选密码(经过各种组合方式后存入字典)，枚举字典中的密码，尝试通过认证的一种攻击手法。

还是举银行采用个人识别码是“4 位数字”的密码的例子，考虑到 用户使用自己的生日做密码的可能性较高，于是就可以把生日日 期数值化，如将 0101~1231 保存成字典，进行尝试。

* 对已加密密码的破解

Web 应用在保存密码时，一般不会直接以明文的方式保存，通过 散列函数做散列处理或加 salt 的手段对要保存的密码本身加密。 那即使攻击者使用某些手段窃取密码数据，如果想要真正使用这 些密码，则必须先通过解码等手段，把加密处理的密码还原成明 文形式。

### 11.5.2 点击劫持

点击劫持(Clickjacking)是指利用透明的按钮或链接做成陷阱，覆盖 在 Web 页面之上。然后诱使用户在不知情的情况下，点击那个链接 访问内容的一种攻击手段。这种行为又称为界面伪装(UI Redressing)。

已设置陷阱的 Web 页面，表面上内容并无不妥，但早已埋入想让用 户点击的链接。当用户点击到透明的按钮时，实际上是点击了已指定 透明属性元素的 iframe 页面。

### 11.5.3 DoS攻击

DoS 攻击(Denial of Service attack)是一种让运行中的服务呈停止状 态的攻击。有时也叫做服务停止攻击或拒绝服务攻击。DoS 攻击的对 象不仅限于 Web 网站，还包括网络设备及服务器等。

主要有以下两种DoS攻击方式：

* 集中利用访问请求造成资源过载，资源用尽的同时，实际上服务业就呈停止状态；
* 通过攻击安全漏洞使服务停止。

其中，集中利用访问请求的 DoS 攻击，单纯来讲就是发送大量的合 法请求。服务器很难分辨何为正常请求，何为攻击请求，因此很难防 止 DoS 攻击。

### 11.5.4 后门程序

后门程序(Backdoor)是指开发设置的隐藏入口，可不按正常步骤使用受限功能。利用后门程序就能够使用原本受限制的功能。









































